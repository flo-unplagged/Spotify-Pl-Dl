!pip3 install youtube-search-python
!pip install pytube
!pip install spotipy
!pip install spotipy.oauth2


import os
import logging
from youtubesearchpython import VideosSearch
from pytube import YouTube
import spotipy
from spotipy.oauth2 import SpotifyClientCredentials


# Configure logging
logging.basicConfig(level=logging.INFO)

# Set up Spotify credentials
client_id = 'c15970bcd75a4ec2bb4492b2f02ae0e3'
client_secret = '20f26dbd28eb448f84f6a99625d2e01f'

# Playlist ID to retrieve
# Id aus Spotify link: nach /playlist/ bis zum "?"
# Beispiel: link: https://open.spotify.com/playlist/3fCY7sF0CzA6frdNAWcj2s?si=fdf6015efee14d79 ID: '3fCY7sF0CzA6frdNAWcj2s'
playlist_id = '7op6WZoQgVZDTNxhRXlmeS'

# wenn mode = "artist" -> Dateiname enth채lt erst K체nstlername, dann Track; sonst umgekehrt
mode = "blub"

# Set up Spotify authentication
auth_manager = SpotifyClientCredentials(client_id=client_id, client_secret=client_secret)
sp = spotipy.Spotify(auth_manager=auth_manager)

# Set up PyTube download directory
DOWNLOAD_DIR = os.path.expanduser("~/downloads")


def search_youtube_videos(search_terms):
    """Searches for YouTube videos given a list of search terms."""
    global youtube_urls
    youtube_urls = {}

    for term in search_terms:
        # Remove leading/trailing whitespaces and newlines from the search term
        term = term.strip()

        try:
            # Search for videos on YouTube
            search = VideosSearch(term, limit=1)
            results = search.result()
            link = results['result'][0]['link']
            youtube_urls[link] = search_terms.get(term) # Zusammenf체gen von youtube link und song id
            logging.info(f"Found YouTube link for '{term}': {link}")
        except Exception as e:
            # Log any exceptions that occur during the search process
            logging.error(f"Error occurred while searching YouTube for '{term}': {str(e)}")
            raise
    return youtube_urls



def download_youtube_video_as_mp3(link):
    """Downloads a YouTube video as an MP3."""
    try:
        yt = YouTube(link)
        stream = yt.streams.filter(only_audio=True, file_extension='mp4').order_by('abr').desc().first()
        track_name = sp.track(youtube_urls.get(link))["name"]  # Name wird 체ber Track ID ausgelesen
        artist_name = sp.track(youtube_urls.get(link))["artists"][0]["name"]
        playlist_name = sp.playlist(playlist_id)['name']
        if mode == "artist":
            mp3_filename = f"{artist_name} - {track_name}.mp3"
        else:
            mp3_filename = f"{track_name} - {artist_name}.mp3"
        logging.info(f"Downloading MP3: {link}")
        download_dir = os.path.join(DOWNLOAD_DIR, playlist_name)
        if not os.path.exists(download_dir):
            os.mkdir(download_dir)
        return stream.download(output_path=download_dir, filename=mp3_filename)
    except Exception as e:
        logging.warning(f"Download failed for link {link}: {str(e)}")
        return None


def main():
    try:
        
        # Retrieve playlist data from Spotify
        playlist = sp.playlist(playlist_id)
        tracks = playlist['tracks']['items']
    
    
        # Extract track names + track ids and artists from the playlist
        search_terms = {}
        for track in tracks:
            search_terms[f"{track['track']['name']} {', '.join([artist['name'] for artist in track['track']['artists']])}"] = f"{track['track']['id']}"

        
        # Search for YouTube links
        youtube_links = search_youtube_videos(search_terms)
        
        
        # Download YouTube videos as MP3
        downloaded_mp3_files = []
        for link in youtube_links:
            mp3_path = download_youtube_video_as_mp3(link)
            if mp3_path is not None:
                downloaded_mp3_files.append(mp3_path)
                logging.info(f"Downloaded MP3: {mp3_path}")
        logging.info("Download abgeschlossen Habibi")


    except Exception as e:
        # Log any exceptions that occur during the main process
        logging.error(f"An error occurred during playlist retrieval and downloading MP3s: {str(e)}")
        raise


if __name__ == "__main__":
    main()
    
    


# bugifx 12.07.23: Pytube/cipher.py function_patterns updaten:

#function_patterns = [
#    # https://github.com/ytdl-org/youtube-dl/issues/29326#issuecomment-865985377
#    # https://github.com/yt-dlp/yt-dlp/commit/48416bc4a8f1d5ff07d5977659cb8ece7640dcd8
#    # var Bpa = [iha];
#    # ...
#    # a.C && (b = a.get("n")) && (b = Bpa[0](b), a.set("n", b),
#    # Bpa.length || iha("")) }};
#    # In the above case, `iha` is the relevant function name
#    r'a\.[a-zA-Z]\s*&&\s*\([a-z]\s*=\s*a\.get\("n"\)\)\s*&&.*?\|\|\s*([a-z]+)',
#    r'\([a-z]\s*=\s*([a-zA-Z0-9$]+)(\[\d+\])?\([a-z]\)', ]

# bugfix 19.7.23: cipher.py transform_match updaten

#     if not transform_match:
#        raise RegexMatchError(caller="get_transform_object", pattern=pattern)
#       # commented the line that raises the error, TEMPORARY FIX
#       # raise RegexMatchError(caller="get_transform_object", pattern=pattern)
#       logger.error(f"No match found for pattern: {pattern}")
#       return []  # Return an empty list if no match is found

#   return transform_match.group(1).replace("\n", " ").split(", ")

